#!/usr/bin/env bash
# force strict mode
set -o pipefail
set -o nounset
set -o errexit


readonly IMAGE_NAME='observability/apm-inyector'
readonly REGISTRY_FULL_IMAGE_NAME="registry.gitlab.com/cencosud-ds/cencommerce/devexp/new-relic-utils/apm-inyector"


# colors utils
readonly BOLD=$(tput bold)
readonly C_RESET=$(tput sgr0)


# print messages with colors and reset
red() {      printf "${BOLD}$(tput setaf 1)${1}${C_RESET}" ; }
blue() {     printf "${BOLD}$(tput setaf 4)${1}${C_RESET}" ; }
green() {    printf "${BOLD}$(tput setaf 2)${1}${C_RESET}" ; }

# util log function
readonly LOG_PREFFIX="$(blue '[')$(green '*')$(blue ']') -"
log_info() { printf "${LOG_PREFFIX} ${@}\n" ; }


# show msg and exit program
die() {
  echo "$(red 'Error:') ${@}" >&2
  exit 1
}


# confirm question and continue
confirm() {
  printf "\n${LOG_PREFFIX} ${@} [y/n]: "
  read ans;
  if [[ "${ans}" != "y" ]]; then exit 1; fi
}


# util to check if your script has dependencies example:
# check_required_programs wget rg fd fzf curl
check_required_programs() {
  for dep in ${@}; do
    which $dep &> /dev/null || die "program '${dep}' is required."
  done
}




run_action() {
  clear
  log_info "Ejecutando contenedor: '${REGISTRY_FULL_IMAGE_NAME}:latest'"
  sleep 1
  docker run --rm -it ${REGISTRY_FULL_IMAGE_NAME}:latest $@
}



build_action() {
  #docker images $IMAGE_NAME | sort 2> /dev/null || true
  #printf "\n${LOG_PREFFIX} Enter new image version: "
  #read version;

  docker build . \
    -t ${REGISTRY_FULL_IMAGE_NAME}:latest \
    -t $IMAGE_NAME:latest

  #-t ${IMAGE_NAME}:${version} \
  #-t ${REGISTRY_FULL_IMAGE_NAME}${version} \
}


# print usage program
usage() {
  local sh_name=$(basename $0)

  cat <<-EOF
  $(blue 'NAME')
      $sh_name

  $(blue 'DESCRIPTION')
      Script Utility for build or run docker image...

  $(blue 'SYNOPSIS')
      $sh_name [options] [args]

  $(blue 'OPTIONS')
      -r | --run                            Run docker gitlab-sanity
      -b | --build                          Build docker image gitlab-sanity
      -h | --help | help                    Print this help screen
EOF

  exit 0
}


# parse script arguments
# exit when unknown option is setted
parse_arguments() {
  [[ $# -eq 0 ]] && usage

  while [[ $# -gt 0 ]]; do
    case $1 in
      -b|--build|build)
        shift
        build_action
        exit
        ;;
      -r|--run|run)
        shift
        run_action $@
        exit
        ;;
      help|--help|-h)
        usage
        ;;
      *)
        echo $(red "ERR: unknown option ${1}") >&2
        usage
        ;;
    esac
    shift  # past key
  done
}


check_required_programs docker
docker ps &> /dev/null || die 'Por favor, asegurate que el servicio de docker este corriendo correctamente.'

parse_arguments $@





