import _ from 'lodash';
import fs from 'fs';
import chalk from 'chalk';
import shell from 'shelljs';
import figlet from 'figlet';
import lolcatjs from 'lolcatjs';
import yargs from 'yargs';
import frameworkRecipes from './src/recipes/index.js';
import * as ui from './src/ui.js';
import * as gitlabCtrl from './src/controller/gitlab.controller.js';
import * as newRelicCtrl from './src/controller/newrelic.controller.js';
import * as scriptUtils from './src/utils.js';
import * as gitlabService from './src/services/gitlabService.js';
import * as jiraService from './src/services/jiraService.js';
import * as git from './src/git.js';
import getConfig from './src/config.utils.js';

const { yellow, red } = chalk;

const jsonPkg = JSON.parse(fs.readFileSync('./package.json'));
const programVersion = jsonPkg.version;

// http://patorjk.com/software/taag/#p=display&f=Slant&t=Type%20Something%20
const logo = figlet.textSync('Apm  Inyector', { font: 'Slant' });

yargs(process.argv.slice(2))
  .version(programVersion)
  .usage(`${yellow(logo)}\nUsage: ${red('./$0')} <option>`)
  .option('gitlab-token', { describe: 'Token de gitlab para consumir las apis' })
  .option('gitlab-group-id', { describe: 'Id de la \'carpeta\' en gitlab donde estan todos los repositorios' })
  .option('gitlab-repo-id', { describe: 'Id del \'proyecto\' al que queremos aplicar el apm.' })
  .option('temp-dir', { describe: 'Directorio de trabajo usado para clonar los repositorios.' })
  .option('delay-text', { describe: 'Es el tiempo expresados en ms del efecto de maquina de escribir' })
  .option('print-config', { describe: 'Imprime la configuracion del script util para solucionar problemas' })
  .option('debug', { describe: 'Aumenta el nivel de log util para solucionar problemas' })
  .option('verbose', { describe: 'Muestra una tabla con los valores de las variables de gitlab del repo procesado' })
  .example(`$ ${red('./$0')} --gitlab-token as3aj3k2jsa --gitlab-group-id 1234911`)
  .example(`$ ${red('./$0')} --gitlab-token as3aj3k2jsa --gitlab-repo-id 1234911 --verbose`)
  .example(`$ ${red('./$0')} --gitlab-token as3aj3k2jsa --gitlab-group-id 1234911 --print-config --autofix`)
  .example(`\n$ ${yellow('export')} GITLAB_TOKEN=as3aj3k2jsa \n$ ${yellow('export')} GITLAB_GROUP_ID=1234911 \n$ ${red('./$0')} --print-config --autofix`)
  .help()
  .wrap(120).argv;


const PROJECT_FOLDER = process.cwd();
const TEMP_FOLDER = getConfig('temp-dir', false, 'temp');
const GIT_REPO_ID = getConfig('gitlab-repo-id', false);
const GIT_GROUP_ID = getConfig('gitlab-group-id', false);



/**
 * initialize.
 */
const initialize = async () => {
  console.log();

  lolcatjs.options.animate = true;
  lolcatjs.options.colors = true;
  lolcatjs.fromString(logo);

  console.log();
  await ui.printTask('*', `Version: ${programVersion}`);
  await ui.printTask('*', 'Inicializando Script ...');

  scriptUtils.mkdir(TEMP_FOLDER);
  shell.cd(TEMP_FOLDER);
};



/**
 * findPreviousJiraBranch.
 */
function findPreviousJiraBranch() {
  let branchName = git.getCurrentBranchName().trim();
  if (branchName) {
    branchName = branchName.trim();
    if (/.New.Relic.APM/.test(branchName)) {
      return branchName;
    }
  }

  return undefined;
}




// iterate proyect list
// FLOW
// TODO: Scenario 1: Si el usuario especifica el '--gitlab-repo-id' buscamos info del repositorio ignorando el '--gitlab-group-id'
// TODO: Scenario 2: Si el usuario especifica el '--gitlab-group-id' buscamos todos los repositorios de ese grupo
// TODO: Scenario 3: Si el usuario no especifica ningun parametro de estos buscamos
// todos los grupos para que los pueda seleccionar.
const getOrChooseRepositories = async () => {
  let reposSelected = [];

  if (GIT_REPO_ID) {
    await ui.printTask('*', `Buscando proyecto con id '${GIT_REPO_ID}' ...`);

    const repo = await gitlabCtrl.getProjectById(GIT_REPO_ID);
    reposSelected.push(repo);
    await ui.printTask(' ', `Repo encontrado '${repo.http_url_to_repo}' ...`);
  } else {
    const groupId = GIT_GROUP_ID || (await gitlabCtrl.chooseGitlabGroup());
    reposSelected = await gitlabCtrl.chooseGitlabRepositories(groupId);
  }

  return reposSelected;
};




/**
 * cloneRepository.
 *
 * @param {object} repo
 */
const cloneRepository = async (repo) => {
  await ui.printTask('\n*', `Clonando repositorio '${repo.ssh_url_to_repo}' ...`);
  if (!git.clone(repo)) {
    return;
  }
  await ui.printTask(' ', `Repositorio clonado en '${PROJECT_FOLDER}/${TEMP_FOLDER}/${repo.name}'`);
};




/**
 * setWorkdir. Change current directory.
 *
 * @param {String} dir
 */
const setWorkdir = async (dir) => {
  await ui.printTask(
    '\n*',
    `Entrando al directorio de trabajo '${TEMP_FOLDER}/${dir}' ...`,
  );
  shell.cd(dir);
  return dir;
};




/**
 * asyncrunRecipe() Verify integration and inject APM
 *
 * @param {...} async{ repo -
 * @param {...} applicationName } -
 * @param {...} recipe -
 *
 * @return {...}
 */
async function runRecipe({ repo, applicationName }, recipe) {
  const component = repo.name;
  await ui.printTask('*', 'Verificando posible integración previa...');
  const precheckResult = await recipe.preCheck(repo);

  if (precheckResult === 'complete-integration' || precheckResult === 'partial-integration') {
    await ui.printTask('*', `${precheckResult} detectado para: '${repo.name}'`);
    return false;
  }
  if (precheckResult === 'error') {
    console.log(`Precheck failed for project: ${component}`);
    return false;
  }

  if (await recipe.execute({ repo, applicationName })) {
    return true;
  }
  console.log(`Injection failed for project: ${component}`);
  return false;
}




const chooseBaseBranch = async () => {
  await ui.printTask('\n*', 'Obteniendo branches ...');
  let { baseBranch, branches } = await git.findBaseBranch();

  // para evitar confusiones a la hora de cambiar el branch
  let i = 0;
  while ((i = branches.findIndex((b) => b.includes('origin/HEAD'))) > -1) {
    branches.splice(i, 1);
  }

  let confirmChangeBranch;
  branches.forEach((b) => console.log(red(`  - ${b.trim()}`)));
  // Cuando el proyecto no tiene los branch standarizados.
  // debemos seleccionar uno
  if (!baseBranch) {
    confirmChangeBranch = 'YES';
  } else {
    await ui.printTask('\n*', `Usando Base branch: '${baseBranch}' ...`);
    confirmChangeBranch = await ui.promptYesNo('Desea cambiar el base branch? ');
  }

  if (confirmChangeBranch === 'YES') {
    baseBranch = await ui.autoComplete('Seleccione su base branch: ', branches);
    await ui.printTask('*', `Usando Base branch: '${baseBranch.trim()}' ...`);
  }

  baseBranch = baseBranch.trim().replace(/origin\//, '');
  return baseBranch;
};




const resetLocalChangesIfNeed = async (baseBranch) => {
  const jiraTicketName = findPreviousJiraBranch();
  if (jiraTicketName) {
    await ui.printTask('*', `Limpiando cambios locales en branch '${baseBranch}' ...`);
    if (git.resetHard(baseBranch) !== 0 || git.clean() !== 0) {
      await ui.printTask(' ', `Error removiendo cambios en '${baseBranch}' ...`);
    }
  }
};




const createJiraTicketIfNeed = async (repoName) => {
  let jiraTicketName = findPreviousJiraBranch();
  if (!jiraTicketName) {
    await ui.printTask('*', 'Creando ticket en Jira ...');
    jiraTicketName = await jiraService.createJiraTicket(repoName);

    await ui.printTask(' ', `Ticket creado '${jiraTicketName}'.`);
  }

  return jiraTicketName;
};




const createNewBranchIfNeed = async (baseBranch, jiraTicketName) => {
  const currentBranch = git.getCurrentBranchName();
  if (!currentBranch.includes(jiraTicketName)) {
    await ui.printTask('*', 'Creando nuevo branch ...');
    await ui.printTask(' ', `git checkout -b ${baseBranch} origin/${jiraTicketName}`);
    return git.createBranchIfNeed(baseBranch, jiraTicketName);
  }
  return undefined;
};




const detectFramework = async (repoName) => {
  await ui.printTask('\n*', 'Detectando framework/stack usado...');
  const framework = scriptUtils.checkProjectFramework('.');
  if (framework === 'unknown') {
    await ui.printTask(' ', red(`WARN: No es posible determinar el framework usado por '${repoName}'.`));
    return undefined;
  }

  await ui.printTask(' ', `Stack usado: '${framework}'.`);
  return framework;
};



const getRecipeForFramework = (framework) => {
  const recipes = {
    'javascript-express': frameworkRecipes.javascriptExpressRecipe,
    'javascript-nestjs': frameworkRecipes.javascriptNestJSRecipe,
    'java-catalina': frameworkRecipes.javaCatalinaRecipe,
    'java-maven-springboot': frameworkRecipes.javaStandaloneRecipe,
    lambda: frameworkRecipes.lambdaRecipe,
  };

  if (framework in recipes) {
    return recipes[framework];
  }

  return undefined;
};




async function makeCodeChanges(repo, applicationName, detectedFramework) {
  try {
    if (!detectedFramework) {
      return false;
    }

    const recipeFn = getRecipeForFramework(detectedFramework);
    if (!recipeFn) {
      await ui.printTask(' ', 'El inyector no tiene soporte para el stack usado.');
      return false;
    }

    const param = { repo, applicationName };
    // puede que el proyecto ya tenga todos los cambios del apm previamente
    if (!(await runRecipe(param, recipeFn, detectedFramework))) {
      return false;
    }

    await ui.printTask('\n*', `Recomendacion: Antes de continuar. Verifique los archivos modificados en '${TEMP_FOLDER}/${repo.name}'`);
    const resp = await ui.promptYesNo('Desea continuar ? ');
    if (resp !== 'YES') {
      return false;
    }
  } catch (err) {
    console.log(err);
    return false;
  }

  return true;
}




const commitChanges = async (detectedFramework) => {
  await ui.printTask('*', 'Git add ...');
  git.add('.');

  await ui.printTask('*', 'Git commit ...');
  const commMsg = `'AutoScript: Added new relic APM integration for project type ${detectedFramework}'`;
  git.commit(commMsg);
};




const pushChanges = async (jiraTicketName) => {
  await ui.printTask('*', 'Verifique sus cambios !');
  const resp = await ui.promptYesNo('Desea ejecutar git push?:');
  if (resp !== 'YES') {
    process.exit(1);
  }

  if (!git.push('origin', jiraTicketName)) {
    console.log('Error pushing changes');
  }
};




const createGitlabEnvironmentsIfNeeds = async (repo, detectedFramework) => {
  if (detectedFramework !== 'lambda') {
    // create gitlab environments
    const envs = await gitlabService.addGitlabProjectEnvironments(repo.id);
    return envs;
  }
  return undefined;
};




const createGitlabVariables = async (repo, repoType, appName, licenceKey, environments) => {
  await gitlabService.addGitlabProjectVariables(repo, repoType, appName, licenceKey, environments);
};





async function processProject(repo) {
  const repoType = await gitlabCtrl.chooseRepoType(repo);
  const applicationName = await gitlabCtrl.chooseApplicationName(repo);
  const nRLicenceKey = await newRelicCtrl.checkNewRelicLicence(applicationName);

  await cloneRepository(repo);
  await setWorkdir(repo.name);
  const baseBranch = await chooseBaseBranch();
  await resetLocalChangesIfNeed(baseBranch);

  const jiraTicket = 'CCMR.New.Relic.APM' || (await createJiraTicketIfNeed());
  await createNewBranchIfNeed(baseBranch, jiraTicket);

  const detectedFramework = await detectFramework(repo.name);

  if (!(await makeCodeChanges(repo, applicationName, detectedFramework))) {
    return;
  }
  commitChanges(detectedFramework);
  await pushChanges(jiraTicket);

  const envs = await createGitlabEnvironmentsIfNeeds(repo, detectedFramework);
  await createGitlabVariables(
    repo,
    repoType,
    applicationName,
    nRLicenceKey,
    envs,
    detectedFramework,
  );

  await gitlabService.createGitlabMR(
    repo.id,
    baseBranch,
    jiraTicket,
    detectedFramework,
  );

  await ui.printTask('*', `Finalizada integración en repositorio '${repo.name}'`);
}




async function main() {
  await initialize();

  const reposSelected = await getOrChooseRepositories();
  if (_.isEmpty(reposSelected)) {
    console.log(red('No se ha seleccionado ningun repositorio.'));
    return;
  }

  for (const repo of reposSelected) {
    if (await gitlabCtrl.hasNewRelicIntegration(repo)) {
      console.log(yellow(' Este proyecto ya tiene la integracion del Apm.'));
      continue;
    }

    await processProject(repo, yargs.argv);
  }

  shell.cd(PROJECT_FOLDER);
  process.exit(0); // required because of readline module
}




main();
