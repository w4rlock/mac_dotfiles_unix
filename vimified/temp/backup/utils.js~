import fs from 'fs';
import shell from 'shelljs';
import * as validate from '../config.validations.js';
import * as fileUtils from './file_utils.js';
import getConfig from './config.utils.js';


const DELAY_TEXT = getConfig('delay-text', false, 15);
const projectFolder = process.cwd();

export const projectReport = {
  byFramework: {},
  byLogKey: {},
  byResult: {
    success: {},
    error: {},
    ignored: {},
  },
};


export const sleep = (ms) => new Promise((res) => setTimeout(() => res(ms), ms));
export const mkdir = (paths) => shell.exec(`mkdir -p ${paths}`, { silent: true });


export function checkScriptOptionFilter(options) {
  let { batchFileFilter } = options;
  if (batchFileFilter) {
    try {
      batchFileFilter = JSON.parse(batchFileFilter);
    } catch (e) {
      console.log('\n\nERROR: invalid param value for \'--batch-file-filter\'');
      // console.log( 'Ex. --batch-file-filter \'{'Tipo': 'Backend', 'Pipeline': 'CodeCommit'}\'\n');
      process.exit(1);
    }
  }

  return batchFileFilter;
}



export function parseProjectName(repoName, environment, countryCode) {
  const projectName = repoName.replace(`${countryCode}-`, '');
  return toKebabCase(`${countryCode}-${projectName}-${environment}`);
}



export function applyFilterObject(arrData, objFilter) {
  return arrData.filter((data) => Object.keys(objFilter).every((field) => data[field] === objFilter[field]));
}


export function logProjectResult(repo, resultState, framework, reason, logKey) {
  if (!framework || framework === 'unknown') {
    framework = 'unknown-framework';
  }
  if (framework !== 'unknown-framework' || logKey === 'framework-detection') {
    const { [framework]: frameworkDict = {} } = projectReport.byFramework;
    frameworkDict[repo.name] = {
      project: repo,
      framework,
      resultState,
      reason,
      logKey,
    };
    projectReport.byFramework[framework] = frameworkDict;
  }

  if (logKey !== 'framework-detection') {
    const { [logKey]: logKeyDict = {} } = projectReport.byLogKey;
    logKeyDict[repo.name] = {
      project: repo,
      reason,
      framework,
      resultState,
      logKey,
    };
    projectReport.byLogKey[logKey] = logKeyDict;
  }

  if (['success', 'error', 'ignored'].includes(resultState)) {
    projectReport.byResult[resultState][repo.name] = {
      project: repo,
      reason,
      framework,
      resultState,
      logKey,
    };
  }
}



export function getMarkdownForFramework(framework) {
  if (framework === 'javascript-nestjs' || framework === 'javascript-express') {
    return fs.readFileSync(`${projectFolder}/markdown/nodejs.md`, {
      encoding: 'utf8',
    });
  }
}

export function checkProjectFramework(directory) {
  if (fileUtils.findFilesByRegex(`${directory}/`, /template.yaml/, /Serverless::Function/, true)) {
    return 'lambda';
  }
  // js
  if (fileUtils.findFilesByRegex(`${directory}/`, /package.json/, /'@nestjs\/.*:/, false)
    && !fileUtils.findFilesByRegex(`${directory}/`, /package.json/, /'react'.*:/, false)) {
    return 'javascript-nestjs';
  }
  if (fileUtils.findFilesByRegex(`${directory}/`, /package.json/, /'express'.*:/, false)
    && !fileUtils.findFilesByRegex(`${directory}/`, /package.json/, /'react'.*:/, false)) {
    return 'javascript-express';
  }
  if (fileUtils.findFilesByRegex(`${directory}/`, /package.json/, /typescript|tsc/, false)
    && fileUtils.findFilesByRegex(`${directory}/`, /tsconfig.json/, undefined, false)) {
    return 'typescript';
  }
  if (fileUtils.findFilesByRegex(`${directory}/`, /package.json/, /'start'.+node/, false)) {
    return 'javascript-node';
  }

  // python
  if (fileUtils.findFilesByRegex(`${directory}/`, /requirements.txt/, undefined, true)
    && fileUtils.findFilesByRegex(`${directory}/`, /Dockerfile/, undefined, false)) {
    return 'python-docker';
  }
  if (fileUtils.findFilesByRegex(`${directory}/`, /requirements.txt/, undefined, true)
    && !fileUtils.findFilesByRegex(`${directory}/`, /Dockerfile/, undefined, false)) {
    return 'python';
  }
  if (fileUtils.findFilesByRegex(`${directory}/`, /pyproject.toml/, undefined, false)) {
    return 'poetry';
  }

  // java
  if (fileUtils.findFilesByRegex(`${directory}/`, /Dockerfile/, /CATALINA_HOME/, false)) {
    return 'java-catalina';
  }
  if (fileUtils.findFilesByRegex(`${directory}/`, /pom.xml/, /org.springframework.boot/, false)) {
    return 'java-maven-springboot';
  }
  if (fileUtils.findFilesByRegex(`${directory}/`, /build.gradle/, /org.springframework.boot/, true)) {
    return 'java-gradle-springboot';
  }


  // web
  if (fileUtils.findFilesByRegex(`${directory}/`, /package.json/, /'react'.*:/, false)) {
    return 'react';
  }
  if (fileUtils.findFilesByRegex(`${directory}/`, /index.php/, undefined, false)) {
    return 'php';
  }

  // other javascript
  if (fileUtils.findFilesByRegex(`${directory}/`, /package.json/, undefined, false)) {
    // return 'javascript-other';
    return 'javascript-express';
  }

  // mobile
  if (fileUtils.findFilesByRegex(`${directory}/`, /build.gradle/, /android/, true)) {
    return 'android-gradle';
  }
  return 'unknown';
}

export function checkScriptRequirements() {
  // check if script has all requirements
  if (!process.env.GITLAB_API_TOKEN) {
    console.log(
      'Environment variable GITLAB_API_TOKEN must be set in order for this script to function properly',
    );
    return false;
  }
  if (!process.env.NEW_RELIC_LICENSE_DICT) {
    console.log(
      'Environment variable NEW_RELIC_LICENSE_DICT must be set in order for this script to function properly',
    );
    return false;
  }
  if (!process.env.JIRA_API_TOKEN) {
    console.log(
      'Environment variable JIRA_API_TOKEN must be set in order for this script to function properly',
    );
    return false;
  }
  if (!process.env.JIRA_API_USER) {
    console.log(
      'Environment variable JIRA_API_USER must be set in order for this script to function properly',
    );
    return false;
  }
  if (!shell.which('git')) {
    console.log('This script requires git');
    return false;
  }
  return true;
}

export function injectAPMLibraryPython() {
  console.log('2- Injecting newrelic library into requirements.txt...');
  const results = fileUtils.pickFilesByCallback('.', (file, content) => /requirements.txt/.test(file) && /newrelic/.test(content), false);
  if (results.length > 0) {
    console.log('Newrelic library was already included...OK');
    return;
  }
  fs.appendFileSync('requirements.txt', 'newrelic==6.2.0.156\n');
}

export function injectDockerFilePython() {
  console.log('3- Injecting ENTRYPOINT to Dockerfile...');
  if (fileUtils.pickFilesByCallback('.', (file, content) => /Dockerfile/.test(file), false).length === 0) {
    console.log('ERROR: No Dockerfile found...OK');
    return false;
  }

  if (fileUtils.pickFilesByCallback('.', (file, content) => /Dockerfile/.test(file)
    && /^ENTRYPOINT/gm.test(content), false).length > 0) {
    if (fileUtils.pickFilesByCallback('.', (file, content) => /Dockerfile/.test(file)
      && /^ENTRYPOINT \['newrelic-admin',.?'run-program'\].*$/gm.test(content), false).length > 0) {
      console.log('ENTRYPOINT already existed...OK');
      return true;
    }

    console.log('ERROR: A different ENTRYPOINT other than the newrelic one was found. Please correct Dockerfile manually');
    return false;
  }

  if (fileUtils.pickFilesByCallback('.', (file, content) => /Dockerfile/.test(file) && /^CMD/gm.test(content), false).length === 0) {
    console.log('ERROR: No CMD found. Please correct Dockerfile manually');
    return false;
  }

  return fileUtils.writeLineToFile('Dockerfile', { writeBefore: true }, /^CMD/gm, 'ENTRYPOINT [\'newrelic-admin\', \'run-program\']');
}

export function injectDockerFileEnvironment(repo) {
  if (!fileUtils.findFilesByRegex('.', /Dockerfile/, undefined, false)) {
    console.log('INFO: No Dockerfile.');
    return true;
  }

  if (!fileUtils.findFilesByRegex('.', /Dockerfile/, /^ENV NEW_RELIC_LICENSE_KEY=/, false)) {
    console.log('Injecting NEW_RELIC_LICENSE_KEY into Dockerfile...');
    if (!fileUtils.writeLineToFile('Dockerfile', { writeAfter: true, findLast: true }, /^FROM/gm, 'ARG NEW_RELIC_LICENSE_KEY')) {
      console.log('ERROR: Could not inject NEW_RELIC_LICENSE_KEY into Dockerfile');
      return false;
    }
    if (!fileUtils.writeLineToFile('Dockerfile', { writeAfter: true }, /^ARG NEW_RELIC_LICENSE_KEY/gm, 'ENV NEW_RELIC_LICENSE_KEY=$NEW_RELIC_LICENSE_KEY')) {
      console.log('ERROR: Could not inject NEW_RELIC_LICENSE_KEY into Dockerfile');
      return false;
    }
  }

  if (!fileUtils.findFilesByRegex('.', /Dockerfile/, /^ARG NEW_RELIC_LABELS=/, false)) {
    console.log('Injecting NEW_RELIC_LABELS into Dockerfile...');
    if (!fileUtils.writeLineToFile('Dockerfile', { writeAfter: true, findLast: true }, /^FROM/gm, 'ARG NEW_RELIC_LABELS')) {
      console.log('ERROR: Could not inject NEW_RELIC_LABELS into Dockerfile');
      return false;
    }
    if (!fileUtils.writeLineToFile('Dockerfile', { writeAfter: true }, /^ARG NEW_RELIC_LABELS/gm, 'ENV NEW_RELIC_LABELS=$NEW_RELIC_LABELS')) {
      console.log('ERROR: Could not inject NEW_RELIC_LABELS into Dockerfile');
      return false;
    }
  }

  // para los proyectos (JS) en aws code commit el NEW_RELIC_APP_NAME se inyecta
  //  en el index.js concatenado con el node_env
  if (validate.isGitlabRepo(repo.ssh_url_to_repo) || repo.isJavaProject) {
    if (
      !fileUtils.findFilesByRegex('.', /Dockerfile/, /^ENV NEW_RELIC_APP_NAME=/, false)) {
      console.log('Injecting NEW_RELIC_APP_NAME into Dockerfile...');
      if (!fileUtils.writeLineToFile('Dockerfile', { writeAfter: true, findLast: true }, /^FROM/gm, 'ARG NEW_RELIC_APP_NAME')) {
        console.log(
          'ERROR: Could not inject NEW_RELIC_APP_NAME into Dockerfile',
        );
        return false;
      }
      if (
        !fileUtils.writeLineToFile('Dockerfile', { writeAfter: true, findLast: true }, /^ARG NEW_RELIC_APP_NAME/gm, 'ENV NEW_RELIC_APP_NAME=$NEW_RELIC_APP_NAME')) {
        console.log(
          'ERROR: Could not inject NEW_RELIC_APP_NAME into Dockerfile',
        );
        return false;
      }
    }
  }

  return true;
}

export const toKebabCase = (str) => str
  && str
    .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)
    .map((x) => x.toLowerCase())
    .join('-');

export function detectRequireJS() {
  let files = fileUtils.findFilesByRegex('.', undefined, /^[\w\s=!''&.]*require\(.newrelic.\)/gm, true);
  if (files) {
    console.log('New relic APM already imported in files:', files);
    return true;
  }
  files = fileUtils.findFilesByRegex('.', undefined, /^[\w\s=!''&.]*import .newrelic./gm, true);
  if (files) {
    console.log('New relic APM already imported in files:', files);
    return true;
  }
  return false;
}

export function detectFile(filename) {
  const files = fileUtils.findFilesByRegex('.', new RegExp(filename), undefined, true);
  if (files) {
    console.log('New relic config file found in:', files);
    return true;
  }
  return false;
}

export function detectLibraryJS() {
  const files = fileUtils.findFilesByRegex('.', /package.json/, /"newrelic":/, true);
  if (files) {
    console.log('New relic library already integrated in file:', files);
    return true;
  }
  return false;
}

export function detectDockerfilePython() {
  const files = fileUtils.findFilesByRegex('.', /Dockerfile/, /^ENTRYPOINT \['newrelic-admin',.?'run-program'\].*$/gm, false);
  if (files) {
    console.log('New relic library already integrated in file:', files);
    return true;
  }
  return false;
}

export function detectLibraryPython() {
  const files = fileUtils.findFilesByRegex('.', /requirements.txt/, /newrelic/, true);
  if (files) {
    console.log('New relic library already integrated in file:', files);
    return true;
  }
  return false;
}

export function injectPackageJson() {
  const files = fileUtils.findFilesByRegex('.', /package.json/, /"newrelic":/, true);
  if (files) {
    console.log('Newrelic library was already included...OK');
    return true;
  }
  const packageFiles = fileUtils.findFilesByRegex(
    '.',
    /package.json/,
    undefined,
    true,
  );
  if (packageFiles.length > 1) {
    console.log('ERROR: Multiple package.json found...');
    return false;
  }
  if (packageFiles.length === 0) {
    console.log('ERROR: No package.json found...');
    return false;
  }
  const packageFileContent = JSON.parse(
    fs.readFileSync(packageFiles[0], { encoding: 'utf8' }),
  );
  packageFileContent.dependencies.newrelic = '^7.3.1';
  fs.writeFileSync(
    packageFiles[0],
    `${JSON.stringify(packageFileContent, null, 2)}\n`,
  );
  return true;
}

export function injectRequireJS() {
  if (detectRequireJS()) {
    return false;
  }
  let injectionFile;
  if (
    (injectionFile = fileUtils.findFilesByRegex('.', /index.js/, undefined, false))
    || (injectionFile = fileUtils.findFilesByRegex('.', /app.js/, undefined, false))
    || (injectionFile = fileUtils.findFilesByRegex('.', /server.js/, undefined, false))
    || (injectionFile = fileUtils.findFilesByRegex('.', /app.js/, undefined, true))
    || (injectionFile = fileUtils.findFilesByRegex('.', /index.js/, undefined, true))
    || (injectionFile = fileUtils.findFilesByRegex('.', /server.js/, undefined, true))
  ) {
    return fileUtils.writeLineToFile(
      injectionFile[0],
      { writeBefore: true },
      /^./,
      'const newrelic = require(\'newrelic\');',
    );
  }
  console.log('Could not find any file to inject');
  return false;
}

export function injectRequireTS(repo) {
  // detects for TS too
  if (detectRequireJS()) {
    return false;
  }

  let injectionFile;
  if (
    (injectionFile = fileUtils.findFilesByRegex('.', /index.js/, undefined, false))
    || (injectionFile = fileUtils.findFilesByRegex('.', /main.ts/, undefined, false))
    || (injectionFile = fileUtils.findFilesByRegex('.', /server.ts/, undefined, false))
    || (injectionFile = fileUtils.findFilesByRegex('.', /index.js/, undefined, true))
    || (injectionFile = fileUtils.findFilesByRegex('.', /main.ts/, undefined, true))
    || (injectionFile = fileUtils.findFilesByRegex('.', /server.ts/, undefined, true))
  ) {
    // Este import debe ir en una linea en particular ya que la logica
    // en el index.js es distinta a los proyectos en gitlab
    if (validate.isAwsRepo(repo.ssh_url_to_repo)) {
      const importAfterExpr = /await\s+(this\.)?setVariables\(/;
      const importStr = '        const newRelic = require(\'newrelic\');';

      const app = parseProjectName(repo.name, '', 'cl');
      const addVariableAfterExpr = /process\.env.*=\s+\get\(secretResolve/;
      const addVariableAppNameStr = `        process.env.NEW_RELIC_APP_NAME = \`${app}-\${process.env.NODE_ENV}\``;

      return (
        fileUtils.writeLineToFile(
          injectionFile[0],
          { writeAfter: true },
          importAfterExpr,
          importStr,
        )
        && fileUtils.writeLineToFile(
          injectionFile[0],
          { writeAfter: true, findLast: true },
          addVariableAfterExpr,
          addVariableAppNameStr,
        )
      );
    }

    return fileUtils.writeLineToFile(
      injectionFile[0],
      { writeBefore: true },
      /^./,
      'const newrelic = require(\'newrelic\');',
    );
  }

  console.log('Could not find any file to inject');
  return false;
}


export async function matrixLog(text = '', delay = undefined) {
  console.log(delay, DELAY_TEXT);
  if (delay === 0 || delay === 'false') {
    console.log(text);
    return;
  }

  for (const letter of text) {
    process.stdout.write(letter);
    // human effect
    await sleep(delay || DELAY_TEXT);
  }
  console.log();
};


